# Ответы на вопросы в Яндекс
[Разработчик интерфейсов](http://company.yandex.ru/job/vacancies/dev_int_yaservices.xml)

## Вопрос 1
Необходимо передать на сервер набор параметров, не перезагружая при этом страницу браузера. Расскажите, как это сделать: перечислите все возможные способы и назовите самый кроссбраузерный.

## Ответ
Можно подключать динамически `iframe`, помещая в путь query-параметры, или даже делать это с помощью изображений. Эти и другие подобные (embeded элементы) извращённые способы крайне кроссбраузерны :) Можно использовать `xhr` с базовым функционалом, перебирая при этом почти десяток названий этого объекта чтобы сработало на ранних IE (5+), в котором он и появился впервые.

Можно использовать `xhr2`, сокеты и другие новые API для продвинутых задач.

Можно поместить форму опять же в `iframe` (так я например делал когда нужно было отправить файл).

Можно использовать какие-нибудь плагины типа `Flash`, но это уже история.

Или вот странный способ инициировать загрузку нативного приложения, обяснив пользователю крайнюю необходимость этого действа и из него слать запросы на сервер и передавать результаты в открытую страницу (если нужно).




## Вопрос 2
Мы уделяем большое внимание производительности наших приложений. Нередко случается, что отдельно взятая функция (например, обработчик события) работает достаточно долго, а вызывается часто, что сильно ухудшает отзывчивость интерфейса.

Предложите общее решение, позволяющее вызывать любую функцию не чаще N раз в секунду, даже если её вызов происходит чаще.


## Ответ

Самый простой и во многих случаях правильный путь — использовать `LoDash` (`_.debounce`).

Если абстрагироваться от библиотек, то, нужно создать функцию высшего порядка но не чистую, а инкапсулирующую состояние, а именно время последнего вызова. 









## Вопрос 3
Напишите функцию, которая из произвольного входящего массива выберет все комбинации чисел, сумма которых будет равняться `10`.


## Ответ
Если отсортировать массив затратив на это некоторые ресурсы можно выиграть много больше, т.к. затем требуется рекурсивный перебор массива.

Ещё на этапе сортировки можно отсечь ноль, если встречается (при этом можно запомнить факт его присутствия и при выводе комбинаций это учесть). Это позволит выиграть ещё немало процессорного времени.

Так же можно отсечь число 10, если встретится и так же запомнить этот факт.

Исключение из массива во время сортировки чисел-повторов исключит повторы в найденных комбинациях бесплатно.

Итак теперь имеем упорядоченный массив без 0 и 10 без повторов.

### 1. Допустим, числа целые неотрицательные.

Ещё на этапе сортировки можно отсечь числа большие 10.

```javascript
var collection = [1, 2, 3, 4, 6, 7, 9]; // input collection sample (SORT, UNIQ, EXTRACT 0 and 10) 

var push = function push (collection, item) {
  collection.push(item);
  return collection;
}

var traceCollection;
var length = collection.length;
var traversal = function(index, sum, trace) {
  var currentIndex, number, currentTrace;
  for (currentIndex = index; currentIndex < length; ++currentIndex) {
    number = collection[currentIndex];
    currentTrace = push([].slice.call(trace), number);
    if (sum + number == 10) {
      traceCollection.push(currentTrace); // add new number combination
    } else if (sum + number < 10) {
      traversal(currentIndex + 1, sum + number, currentTrace);
    } else return; // if collection sorted 
  }
};

traceCollection = []; traversal(0, 0, []); traceCollection
// --> [[1,2,3,4],[1,2,7],[1,3,6],[1,9],[3,7],[4,6]]
```

### 2. Если допускаются отрицательные числа

Тогда недопустимо прерывание алгоритма при достижении чисел больших 10-ти, т.к. они будут компенсироваться отрицательными.
В остальном решение аналогично.

### 3. Если допускаются дробные числа и задана точность
 Важно чтобы была задана точность. 
> В остальном решение аналогично.
